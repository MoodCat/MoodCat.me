% Evaluation of the functional modules and the product in its entirety, including the failure analysis

\chapter{Evaluation of the functional modules and product}

Moodcat is roughly developed in four modules.
For the backend we can distinguish the persistence layer, the backend layer and the API presentation layer.
The frontend can be considered a module on itself.
In the following paragraphs we will describe how we reflect on the implementation of these modules.

One of the more controversial choices in our project is undoubtedly the relatively heavy usage of software dependencies and generated code.
The downside of this approach is that we all had to learn and adapt to the used libaries and frameworks.
On the other hand, however, the used libaries and frameworks really set the bar on code quality and kickstarted our project.
We would defenitely use JAX-RS, AngularJS and Hibernate again if we had to write a web system for future projects, and we are glad that we took this project as the opportunity to work with these tools.

If we would have to pinpoint two failures in the development process, we can list two major design problems. One failure was that we did not know our ORM framework (Hibernate) well enough. This led to quite some bugs which involved low level debugging in the framework.
Eventually we got it fixed but it took relatively much time. Most of the problems were caused because we wanted to synchronize chat messages in the database so that another server would be able to take over in case of a failure or when scaling out, but in the end we can debate if this was such a good idea to implement something so complex for something that is "nice to have".

For the web interface there is still some room for improvement/ Most important was the unclear positioning of various elements, and the lack of descriptive headers where something might not be intuitive.
The only real failure we experienced in the UI layer was that the two ways of listening to music (the classification game and the room listening) have quite some conflicting logic which had to be dealt with.
Because we designed these views / features separately, we did not plan out how transitions between the two modes would be handled well enough. This caused quite some bugs that had to resolved later on, and the implementation of these fixes can still be improved using, for example - a state pattern.

Overall we are really happy about the product we have built in the past few weeks.
First of all, the product we have built is in a deployable state, and almost all feedback from our current user group was positive.
Secondly, we have managed to realize almost all must have requirements, and missed just one should have requirement. This of course besides the neural network, which we unfortunately had to drop in the development process.
We however do think that the neural network that we designed would work in practise and that it would be a huge improvement both to the functioning and user experience of the system.%TODODODO insert the actual references
Without the neural network, the system is suffering from a cold start problem, which over time will be solved through user input. In fact, the user input is also building a dataset to train a future neural network with.

% Evaluation of the functional modules and the product in its entirety, including the failure analysis

\chapter{Evaluation of the functional modules and product}

Moodcat is roughly developed in four modules.
For the backend we can distinguish the persistence layer, the backend layer and the API presentation layer.
The frontend can be considered a module on itself.
We will now describe how we reflect on the implementation of these modules.

One of the more controversial choices in our project is undoubtedly the relatively heavy usage of software dependencies and generated code.
The downside of this approach is that we all had to learn and adapt to the various libaries and frameworks.
On the other hand, however, the used libaries and frameworks really set the bar on code quality and kickstarted our project.
We would defenitely use JAX-RS, AngularJS and Hibernate again if we had to write a web system for future projects and we are glad that we took this project as the opportunity to work with these tools.

If we would have to pinpoint two failures in the development process, we can list two design problems.
One failure was that we did not know our ORM framework (Hibernate) well enough.
This led to quite some bugs which involved low level debugging in the framework.
Eventually we got it fixed but it took relatively much time.
Most of the problems were caused because we wanted to synchronize chat messages in the database so that another server would be able to take over in case of a failure or when scaling out.
But in the end we can debate if this was such a good idea to implement something so complex for something that is "nice to have".

For the web interface there is still some room for improvement.
Most importantly the unclear positioning of various elements and the lack of descriptive headers made some parts of the website not so intuitive.
The only real failure we encountered in the UI layer was that the two ways of listening to music (the classification game and the room listening) had quite some conflicting logic which had to be dealt with.
Because we designed these views / features separately, we did not plan out how transitions between the two modes would be handled well enough.
This caused some bugs that had to resolved later on and the implementation of these fixes can still be improved using, for example - a state pattern.

Aside from these two failures, we we are really happy overall about the product we have built in the past few weeks.
First of all, the product we have built is in a deployable state and almost all feedback from our current user group was positive.
Secondly, we have managed to realize almost all must have requirements, and missed just one should have requirement.
This of course besides the neural network, which we unfortunately had to drop in the development process.
We however do think that the neural network that we designed would work in practice and that it would be a huge improvement both to the functioning and user experience of the system.%TODODODO insert the actual references
Without the neural network, the system is suffering from a cold start problem.
Thi will be solved over time through processing user input.

\chapter{Reflection on the product and process from a software engineering perspective}
In this chapter, we discuss the software engineering perspectives of MoodCat. First, we discuss our developing process. Second, we discuss the general structure and architecture of the product. Then we dive a bit deeper into the design paterns we use and considered. We also touch on code readability and maintainability, and the choices we made there. Finally, we list our most important libraries and languages used.

\section{Product Architecture}
The basic model of MoodCat's architecture is the same as just about every other website.
We're using a client-server architecture.
We actually do this in the form of an AngularJS web application and a Java API based on JAX-RS\footnote{The implementation we use is RestEASY, which can be found on \url{http://resteasy.jboss.org/}}. 
The API in turn talks to a persistence server in the form of a PostgreSQL database.

\section{Design Patterns}
A lot of the design patterns in our application come from the libraries and frameworks we use. However, we did design our backend system very methodically, using the model-view-controller (MVC) pattern. The API classes define the view of the application, in the form of JSON responses, which is what our frontend uses to get it's data. The "backend" package is what defines the controller of the system, and the DAO's (Data Access Object) define our models. They talk to the postgreSQL database for retrieval and persistence.

In the frontend we use a slightly different structure, most commonly referred to MVVM (Model, View, ViewModel). The models here are the API calls, controllers and services are the viewmodels, and the HTML templates are the views.

A few of the design patterns we used:
\begin{enumerate}
\item Facade
\item Proxy
\item Singleton
\item Factories
\item Dependency Injection
\item MVC
\item MVVM
\item Resource pool
\end{enumerate}

\section{Code readability / maintainability}
In our efforts to create a codebase that not only fit our needs, but is readable and maintainable by others as well, we valued clean, short code greatly. Methods are as small as possible, fill only one purpose and have descriptive names. 

We used the new technologies in Java 8 to it's full potential, substituting for loops and (nested) if statements for lambdas and anonymous classes wherever applicable.

Communication with the database is something you want to do right, so instead of sending strings with SQL statements to the database, we built SQL commands with QueryDSL, which implements the builder pattern to create readable strings. Added benefit was the type checking capability of this pattern, decreasing the risk of a poorly written statement to mess with data too much.

Google Guice allowed us to build our application like LEGO: composition at its best. Guice is a Dependency Injection framework, which allows for looser coupling between classes. Responsibilities are split better and rapid prototyping is possible without having to pass dependencies around in the project.

Lastly, our very architecture in the backend allows for much greater maintainability. Due to the MVC-like structure, with different layers of concerns, small changes to these objects were possible without breaking the API contract with the frontend and/or without breaking the database schema. 

\section{SCRUM}
We worked with the SCRUM-methodology for the second time.
Agile methodologies were known to some of us before this project, but no one had really used it consistently, aside from the basics of SCRUM during the SEM course.
We did some research and found a really nice guide from Atlassian\footnote{https://www.atlassian.com/agile}.
From this, we learned about the roles of SCRUM, the difference between the SCRUM Master and the Product Owner, and how to arrange meetings.
A clear plan was set: We were to have daily SCRUM meetings at 09.00 o'clock every morning.
In this meeting, we would take our Waffle\footnote{http://waffle.io} board, and each member of the group had to answer 4 questions:
\begin{enumerate}
\item What have you done yesterday?
\item What are you going to do today?
\item Are you on schedule?
\item Do you need help on anything?
\end{enumerate}
This went surprisingly well!
In our first sprint we had a little trouble guessing how long an issue would take, but after that, we set story points on waffle.io, where 1 story point = 2 hours of work.
SCRUM meetings were useful to keep an overview of the system, as well as help others out when they were stuck.
We did continue past 15 minutes a few times, but usually with a smaller group for a specific issue.
Overall, we're all convinced SCRUM is a great way to develop software, on the condition that a sprint takes 2 or 3 weeks instead of one.
A single week is very short, because the sprint planning and sprint reflection took up a considerable amount of time in the sprint, and the weekly demo forced us to put a difficult issue aside more than once.

\section{Use of libaries and languages}
We have used quite a lot of languages and libraries.
To get a clear view of what belongs where, we split the system in our three components.

\subsection{Frontend}
The frontend for Moodcat is the website loaded into the user's browser.

\subsubsection{Languages}
To create a website, we use quite standard web languages.
HTML for the DOM creation, javascript for client-side logic, DOM manipulation and communication with the backend API, and CSS for styling.

\subsubsection{Libraries}
Everything we do on the frontend, we could do in vanilla javascript (without libraries).
However, this would take extremely long, due to the complexity of the required code.
To solve this problem, we decided to use AngularJS.
This is a framework built upon javascript, and it deals exceptionally well with DOM updates (with 2-way data binding) and HTTP calls.
It also enables re-usable code with directives, a mechanism to create an on the fly webcomponent.
We actually extend AngularJS further with packages to suit our specific needs, these dependencies can be found in the Frontend repo, in the bower.json file.\\

For CSS we use SASS, a CSS preprocessor that eases the re-use of CSS rules and markup.

\subsection{Backend}

\subsubsection{Languages}
In the backend, we use Java.
We've chosen Java because everyone in our team can write good, clean Java code.
It's also very easy to add libraries to Java to ease the task at hand. 

\subsubsection{Libraries}
In fact, we've used quite a few libraries.\\
To turn the application into a servlet so we can use it on the web we use Jetty.
For the RESTful API connection with the website we use RestEASY, a library that implements JAX-RS.
Part of JAX-RS is a dependency injection module, but it's very basic.
We wanted a more complete dependency injection package, so we tied Guice into RestEASY, together with Guice JPA for transaction support and Guice assisted inject for factories.

For the database side of things we're using Hibernate for ORM (Object-relational mapping).
This allows us to transparently "store" Java objects in the database.
Tables are generated to suit the object fields.
To query the database we're using QueryDSL, so we can build queries using a Builder pattern.

To replace our initial plans of a Neural Network, we're using rtrees, which are spatial indices for objects.
To get support for that in our application, we're using Hibernate Spatial.

For development, we're using two more major dependencies.
To simulate a postgres database during testing we're using H2 (with Hatbox for spatial query support).
Besides that, we're using Project Lombok for automatic generation of getters, setters and hashcode and equals methods.

\chapter{Introduction}
\setheader{Introduction}
This document provides a sketch of the system that is going to be built during the context project multimedia services. The architecture of the system is explained in the form of high level components of the system. These components are split in to sub components and sub-systems.

\section{Design goals}
The following design goals will be maintained throughout the project:
\begin{itemize}

\item
\textbf{Deployability}
\\
The system will be developed in such a way that we can always deploy the most current version (Continuous Integration \cite{Duvall}).
Being able to deploy the system at any time allows us to keep the work required for a release manegable.
Because the current version should be deployable at anytime, developers are enforced to only alter the system in a non-breaking way.
Another advantage is that smaller releases\footnote{With smaller we mean releases that touches only a few lines or a few files of the codebase.} imply a lower possibility of introducing bugs.

\item
\textbf{Portability}
\\
The frontend should work on \textit{Evergreen} browsers \footnote{<<The term "evergreen browser" refers to browsers that are automatically upgraded to future versions, rather than being updated by distribution of new versions from the manufacturer, as was the case with older browsers.>> - http://www.techopedia.com/definition/31094/evergreen-browser}.
The backend should run on both Windows and Linux server environments.

\item
\textbf{Simplicity}
\\
The system will be developed with simplicity in mind.
Existing libraries and frameworks will be investigated and used if applicable, so we can focus on developing the system rather than the tools required to build the system.
This will keep our codebase relatively small and limited to the product.
% By using dependencies we do not reduce the overall complexity, in fact, these dependencies will most likely include unused funcitonality and come with a learning curve for the developers.
% ^ Not sure what to do with this line, please take into account with review - JW

\item
\textbf{Object-oriented programming}
\\
Object-oriented programming\cite{Wirfs-Brock} will be used to develop the system.
We will separate the system into subsystems and components (packages, classes and interfaces).
This should enable code reuse and extensibility, and improve the testability of the sytem, because each component can be tested individually\cite{Binder}.

\item
\textbf{Usability}
\\
Users should be able to use Moodcat intuitively.
% Insert more

\end{itemize}

\chapter{Software architecture views}
This chapter discusses the architecture of the system.
The system is first decomposed into smaller subsystems and the dependencies between the subsystems are explained.
In the second paragraph the relation between the hardware and software of the system is elaborated.
The third paragraph illustrates the data management of the system.

\section{Subsystem decomposition}
Moodcat is subdivided into two components: the frontend and the backend service.
In this chapter we will explain how these components are composed and how they interact with each other.

\subsection{Moodcat Frontend}
The Moodcat frontend is the webpage that users navigate to in order to use our service.
In the frontend users can find music listening rooms by their mood.
When a user selects a mood, a request for suggested rooms is sent to the backend.
The backend will respond to this request with an ordered list of listening rooms.
These room suggestions will be rendered on the user interface.
A user can then join a specific room.
The current song and latest chat messages in the room will be fetched from the server.



\subsection{Moodcat Backend}
\subsubsection{REST API}
\subsubsection{Music matching algorithm}

\section{Hardware/software mapping}
\section{Persistent data management}
\section{Concurrency}

% The MoSCoW model is used to structure the high-level product backlog.
% The items are listed according to the priority in relation to the other items in the backlog.
% The backlog is translated to an actual list of issues on GitHub which is ordered using Waffle\cite{waffle}.
%\include{requirements}
%\section{Roadmap}
%The roadmap below shows a general overview of the goals for each SCRUM sprint in a week.
%This is an early planning and is expected to change.
%\begin{itemize}
%\item Week 1: Product setup\\
%This week we will setup our development environments and start brainstorming.
%\begin{itemize}
%\item Set up GitHub project \cite{githubRepo}
%\item Create initial idea of MoodCat
%\end{itemize}
%\end{itemize}
%\chapter{Product backlog}
%\section{User stories of features}
%\section{User stories of defects (if applicable)}
%As of the time of writing, no defects have been discovered.
%\section{User stories of technical improvements (if applicable)}
%As of the time of writing, no technical improvements were made.
%\section{User stories of know-how acquisition}
%\section{Initial release plan}
% \chapter{Definition of Done}


\chapter{Glossary}
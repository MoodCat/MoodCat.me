\chapter{Product}

\section{High-level product backlog}
The MoSCoW model is used to structure the high-level product backlog.
The items are listed according to the priority in relation to the other items in the backlog.
The backlog is translated to an actual list of issues on GitHub which is ordered using Waffle\cite{waffle}.
\input{requirements}

\section{Roadmap}
The roadmap below shows a general overview of the goals for each SCRUM sprint in a week.
This is an early planning and is expected to change.

\begin{itemize}
\item Week 1: Product setup\\
This week we will setup our development environments and start brainstorming.

\begin{itemize}
\item Set up GitHub project \cite{githubRepo}
\item Create initial idea of MoodCat
\end{itemize}

\item Week 2: Sprint 1\\
This week we will focus on setting up a Graphical User Interface to let the user interact with the product.
We also concretized our idea further, and wrote an initial product vision.

\begin{itemize}
\item Set up initial version of frontend.
\item Write product vision draft.
\end{itemize}

\item Week 3: Sprint 2\\
This week we will set up a connection between the frontend and backend system.

\begin{itemize}
\item Create various APIs on the backend.
\item Develop frontend to backend connection.
\item Develop interface on frontend to use APIs.
\end{itemize}

\item Week 4: Sprint 3\\
The first version of the music-matching algorithm will be created using Test-Driven Development (TDD)\cite{TDD}.

\begin{itemize}
\item Choose songs to use as test data.
\item Create testcases to measure the performance of our algorithm.
\item Create initial version of algorithm.
\end{itemize}

\item Week 5: Sprint 4\\
The music-matching algorithm will be extended.

\begin{itemize}
\item Assess the quality of the initial algorithm.
\item Incorporate user feedback in the algorithm.
\end{itemize}

\item Week 6: Sprint 5\\
The music-matching algorithm will be tweaked and extended. We also review our own code and test quality, since we're half way.

\begin{itemize}
\item Review code and test quality.
\item Improve Algorithm
\end{itemize}

\item Week 7: Sprint 6\\
We will apply Sig feedback and implement an auto room creation system.

\begin{itemize}
\item Apply Sig feedback.
\item Implement auto room creation system.
\end{itemize}

\item Week 8: Sprint 7\\
Finish documentation and start final report.

\begin{itemize}
\item Finish architecture design document.
\item Create final report.
\end{itemize}


\item Week 9: Sprint 8\\
Finish final report and prepare presentation.

\begin{itemize}
\item Finish final report.
\item Prepare and practise presentation.
\end{itemize}


\end{itemize}

\chapter{Product backlog}

\section{User stories of features}

\section{User stories of defects (if applicable)}
As of the time of writing, no defects have been discovered.

\section{User stories of technical improvements (if applicable)}
As of the time of writing, no technical improvements were made.

\section{User stories of know-how acquisition}

\section{Initial release plan}


\chapter{Definition of Done}
We need to set a definition of done.
This entails that for every feature, sprint and the end product, we will define what we consider "done".\\

A feature is done when it is unit tested to such an extend that our set coverage is reached. This implies the feature works as defined. Code written for the feature must also be documented and follow our checkstyle and markup rules. Finally, the feature must be reviewed by at least one team member that was not directly involved in creating the code and tests. If all these prerequisites are met, the Pull-Request can be merged.\\

A sprint is considered done when the application is in a working, deliverable state. This entails that all features in the codebase are done (as described above). The system also has to be manually tested for the main interaction with the system. Lastly, integration tests are created and ran succesfully.\\

The final product is considered done if it passes a few criteria. First of all, the system must be unit and integration tested, and it must be manually inspected for all common user interactions. All must-have requirements must be implemented. If a should-have requirement is not implemented, this has to be agreed upon by all team members with a valid reason, and the product should still be usable without the feature. Code is consistent, validated by the SIG test and documented.

\chapter{Glossary}
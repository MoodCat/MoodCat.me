\chapter{Product}

\section{High-level product backlog}
The MoSCoW model is used to structure the high-level product backlog.
The items are listed according to the priority in relation to the other items in the backlog.
The backlog is translated to an actual list of issues on GitHub which is ordered using Waffle\cite{waffle}.
\input{requirements}

\section{Roadmap}
The roadmap below shows a general overview of the goals for each SCRUM sprint in a week.
This is an early planning and is expected to change.

\begin{itemize}
\item Week 1: Product setup\\
This week we will setup our development environments and start brainstorming.

\begin{itemize}
\item Set up GitHub project \cite{githubRepo}
\item Create initial idea of MoodCat
\end{itemize}

\item Week 2: Sprint 1\\
This week we will focus on setting up a Graphical User Interface to let the user interact with the product.
We also concretized our idea further, and wrote an initial product vision.

\begin{itemize}
\item Set up initial version of frontend.
\item Write product vision draft.
\end{itemize}

\item Week 3: Sprint 2\\
This week we will set up a connection between the frontend and backend system.

\begin{itemize}
\item Create various APIs on the backend.
\item Develop frontend to backend connection.
\item Develop interface on frontend to use APIs.
\end{itemize}

\item Week 4: Sprint 3\\
The first version of the music-matching algorithm will be created using Test-Driven Development (TDD)\cite{TDD}.

\begin{itemize}
\item Choose songs to use as test data.
\item Create testcases to measure the performance of our algorithm.
\item Create initial version of algorithm.
\end{itemize}

\item Week 5: Sprint 4\\
The music-matching algorithm will be extended.

\begin{itemize}
\item Assess the quality of the initial algorithm.
\item Incorporate user feedback in the algorithm.
\end{itemize}

\item Week 6: Sprint 5\\
The music-matching algorithm will be tweaked and extended. We also review our own code and test quality, since we're half way.

\begin{itemize}
\item Review code and test quality.
\item Improve Algorithm
\end{itemize}

\item Week 7: Sprint 6\\
We will apply Sig feedback and implement an auto room creation system.

\begin{itemize}
\item Apply Sig feedback.
\item Implement auto room creation system.
\end{itemize}

\item Week 8: Sprint 7\\
Finish documentation and start final report.

\begin{itemize}
\item Finish architecture design document.
\item Create final report.
\end{itemize}


\item Week 9: Sprint 8\\
Finish final report and prepare presentation.

\begin{itemize}
\item Finish final report.
\item Prepare and practise presentation.
\end{itemize}


\end{itemize}

\chapter{Product backlog}

\section{User stories of features}
As a user,\\
When I start the app,\\
Then I should see a mood-selection page.

As a user,\\
When I select a mood,\\
Then I should see a list of rooms.

As a user,\\
When I select a room,\\
Then the current song should be played.

As a user,\\
When I select a room,\\
Then I should see a chat box.

As a user,\\
When I type in the chat message input field,\\
And I click on 'Send message',\\
Then the message should be send to the backend.

As a user,\\
When a user in my current room sends a message to the backend,\\
Then I should see that message in the chat box.

As a user,\\
When I click on the 'thumbs up' or 'thumbs down' buttons,\\
Then the system should alter according to the feedback to enhance the song-selection algorithm.

As a user,\\
When I click on the 'mute' button,\\
Then the music should be muted.

As a user,\\
When I join a room,\\
Then I should see the latest messages sent in this room.

\section{User stories of defects (if applicable)}
As of the time of writing, no defects have been discovered.

\section{User stories of technical improvements (if applicable)}
As of the time of writing, no technical improvements were made.

\section{User stories of know-how acquisition}

\section{Initial release plan}


\chapter{Definition of Done}
We need to set a definition of done.
This entails that for every feature, sprint and the end product, we will define what we consider "done".\\

A feature is completed when it is implemented according to its specification and the code is well tested using unit tests.
Furthermore, the public API (the public methods) of introduced classes should be well-documented using JavaDoc or NgDoc and follow our checkstyle and markup rules.
Finally, the feature must be reviewed by at least one team member that was not directly involved in creating the code and tests.
If all these prerequisites are met, the pull request can be merged.\\

We will use sprint iterations of one week. All stories assigned for a sprint should be done at the end of a sprint.
% If a story could not be completed in the sprint, it will be copied to the next sprint and this will be discussed in the sprint reflection in order to prevent planning failures in the future.
The system also has to be manually tested for the main interaction with the system. Lastly, integration tests are created and ran succesfully.\\

The final product is done when all requirements are fulfilled and the implementation matches the specification. The implementation should be well tested using unit tests and preferably integration / end-to-end tests as well.
If a should-have requirement is not implemented, this has to be agreed upon by all team members with a valid reason, and the product should still be usable without the feature.
Code is consistent, validated by the SIG test and documented.

\chapter{Glossary}